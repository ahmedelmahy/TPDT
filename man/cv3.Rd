% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv3.R
\name{cv3}
\alias{cv3}
\title{Leave-one-out cross validation for smoothing parameter selection}
\usage{
cv3(y, timemat, rangevals, nbas = NULL, with.na = FALSE, trace = F, seed,
  ncpus = 1)
}
\arguments{
\item{y}{[Matrix] of observed data. Columns correspond to individuals and rows to measurements 
over time.}

\item{timemat}{[Matrix] of timepoints with one column per individual. Should be corresponding to the y matrix.}

\item{rangevals}{[vector] with first and last time points.}

\item{nbas}{[scalar] number of basis function to use.}

\item{trace}{[logical] Should the optimization process be traced?}

\item{seed}{[scalar] Set seed to get reproducible results.}

\item{ncpus}{[scalar] Number of CPUs to use. Should only be used for large numbers of individuals.}

\item{check.na}{TODO}
}
\value{
[scalar] The optimal smoothing parameter.
}
\description{
Computes optimal smoothing parameter through leave-one-out cross validation.
}
\details{
Internal function for choosing the smoothing parameter.
}
\examples{
# Not run:
# if(require(fda)) {
#   f <- function(x) 2*x*sin(x)+10+rnorm(1)
#   df <- data.frame(expand.grid(time = 1:10, group = 1:2, id = 1:6))
#   df$data <- f(df$time)
#   ss <- split(df, list(df$group, df$id))
#   obsl <- lapply(ss, function(l) l$data)
#   timel <- lapply(ss, function(l) l$time)
#   ntp <- length(unique(df$time))
#   datmat <- matrix(unlist(obsl), byrow = FALSE, nrow = ntp)
#   timemat <- matrix(unlist(timel), byrow = FALSE, nrow = ntp)
#   
#   lambda <- cv3(y = datmat, timemat = timemat, rangevals = range(df$time),
#                 nbas = 5, ncpus = 1)
#   basis <- fda::create.bspline.basis(rangeval = range(df[,"time"]), nbasis = 5)
#   Par <- fda::fdPar(fdobj = basis, Lfdobj =  2, lambda = lambda)
#   
#   n <-  length(timel[[1]])
#   timepoints <- matrix(unlist(timel), nrow = ntp, ncol = n)
#   # get coefficients of smoothed functions for each group 
#   sm1 <- fda::smooth.basis(argvals = timepoints, 
#                            y = matrix(df[df$group == 1,"data"], 
#                                       nrow = ntp, ncol = n), Par)
#   sm2 <- fda::smooth.basis(argvals = timepoints, 
#                            y = matrix(df[df$group == 2,"data"], 
#                                       nrow = ntp, ncol = n), Par)
#   
#   plot(sm1)
#   points(df[df$group == 1, "data"])
#   points(df[df$group == 2, "data"])
# }
}


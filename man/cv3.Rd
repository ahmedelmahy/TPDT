% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/cv2.R
\name{cv3}
\alias{cv3}
\title{Leave-one-out cross validation for smoothing parameter selection}
\usage{
cv3(y, timemat, rangevals, nbas = NULL, with.na = FALSE, trace = FALSE,
  seed, ncpus = 1)
}
\arguments{
\item{y}{[Matrix] of observed data. Columns correspond to individuals and rows to measurements
over time.}

\item{timemat}{[Matrix] of timepoints with one column per individual. Should be corresponding to the y matrix.}

\item{rangevals}{[vector] with first and last time points.}

\item{nbas}{[scalar] number of basis function to use.}

\item{with.na}{[logical] Are there missing values?}

\item{trace}{[logical] Should the optimization process be traced?}

\item{seed}{[scalar] Set seed to get reproducible results.}

\item{ncpus}{[scalar] Number of CPUs to use. Should only be used for large numbers of individuals.}
}
\value{
[scalar] The optimal smoothing parameter.
}
\description{
Computes optimal smoothing parameter through leave-one-out cross validation.
}
\details{
Internal function for choosing the smoothing parameter.
}
\examples{
f <- function(x) 2*x*sin(x)+10

df <- make_data(shift = 5, n = 2, sd1 = .5, sd2 = .5,
           ntimepoints = 10, type = "shift", f = f)
           nbas <- 5
ss <- split(df, list(df$group, df$id))
obsl <- lapply(ss, function(l) l$data)
timel <- lapply(ss, function(l) l$time)
ntp <- length(unique(df$time))
datmat <- matrix(unlist(obsl), byrow = FALSE, nrow = ntp)
timemat <- matrix(unlist(timel), byrow = FALSE, nrow = ntp)

lambda2 <- cv3(y = datmat, timemat = timemat, rangevals = range(df$time),
                 nbas = nbas, ncpus = 4)
basis <- create.bspline.basis(rangeval = range(df[,"time"]), nbasis = nbas)
Par <- fdPar(fdobj = basis, Lfdobj =  2, lambda = lambda2)

n <-  length(timel[[1]])
timepoints <- matrix(unlist(timel), nrow = ntp, ncol = n)
# get coefficients of smoothed functions for each group
sm1 <- smooth.basis.na(argvals = timepoints,
                       y = matrix(df[df$group == 1,"data"], nrow = ntp, ncol = n), Par)
sm2 <- smooth.basis.na(argvals = timepoints,
                       y = matrix(df[df$group == 2,"data"], nrow = ntp, ncol = n), Par)

plot(sm1)
points(df[df$group == 1, "data"])
points(df[df$group == 2, "data"])
}

